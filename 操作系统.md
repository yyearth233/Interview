# 操作系统

#### 1. Linux 线程启动的方式
手工启动
    前台启动 `$ find / -name a.jpg `
    后台启动 `$ find / -name a.jpg &`
调度启动
    指定时间，触发条件等由系统自动启动。
    `crontab`, `at`,...

#### 2. Linux C 线程启动的方式

3 种 

```c
// 执行命令行命令，阻塞
int system(const char* cmd);

// exec 系列，替换当前进程
int execl (const char *path, const char *arg0, ..., (char*)0);
int execlp(const char *file, const char *arg0, ..., (char*)0);
int execle(const char *path, const char *arg0, ..., (char*)0, char *const envp[]);
...

// 复制当前进程，产生新的进程
pid_t fork();
```
#### 用户态与内核态

一个 linux 进程有 4 GB 内存空间，0～3 GB 是用户空间。
3～4 GB 是内核空间，共享。

特权级：Intel x86 cpu 有 4 级，0～3 级。0 级最高。
系统关键的任务需要分给特权级最高线程执行。
如分配物理内存，拷贝父进程信息，...

一个进程执行自己的代码的时候处于 用户态，此时特权级最低 3 级。
3 级不可以访问 0 级的地址空间。
当系统调用执行内核代码时，切换为 内核态，0 级。此时进程有自己内核栈。

用户运行一个程序，该程序创建的进程开始时运行自己的代码，处于用户态。如果要执行文件操作、网络数据发送等操作必须通过 write、send 等系统调用，这些系统调用会调用内核的代码。进程会切换到 Ring0，然后进入 3～4GB 中的内核地址空间去执行内核代码来完成相应的操作。内核态的进程执行完后又会切换到 Ring3，回到用户态。

用户内存地址与内核内存地址分开，起到保护作用。
防止了黑客通过应用程序攻击操作系统。
用户态不可以访问内核态地址，内核态进程可以通过一定方式访问用户态地址。

#### 用户态切换到内核态的方法

3 种
1) 系统调用：用户态进程主动切换到内核态。向系统申请执行内核程序。
fork() 执行了创建新线程的系统调用。
2) 异常：
出现一些异常，导致从用户态转向内核态，处理异常进程。
3) 外围中断
外围设备发出中断信号，cpu 暂停执行下一条指令，转向中断程序。

系统调用：进程主动
异常，外围中断：被动

#### Linux 常用命令
```shell
cd, pwd, ls -al, mkdir, rmdir, rm -rf, mv, cp, ...
zip -r, 
tar -zxvf xxx.tar.gz -C .../
tar -czvf xxx.tar.gz /etc

cat, more, head, tail, less
grep, sed, awk

chmod, chown, chgrp

top, netstat, ps
df -h 硬盘大小, du -h a.log 看文件大小,
```

#### 进程与线程

一个程序至少有一个进程,一个进程至少有一个线程.

线程是进程的组成部分，一个进程可以拥有多个线程，而一个线程必须拥有一个父进程。

进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。

CPU 角度：
进程和线程都是一个时间段的描述，是CPU工作时间段的描述。
进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文 + CPU执行 + CPU保存上下文
程序A得到CPU -> CPU加载上下文 -> 开始执行程序A的a小段 -> 执行A的b小段 -> 执行A的c小段 -> CPU保存A的上下文。
a, b, c 就是线程。线程是共享了进程的上下文环境，的更为细小的CPU时间段。

#### 进程间通信 IPC 的方法

1) 匿名管道 pipe：单向流动，父子关系进程间通信。
2) 有名管道 named pipe: 单向流动，可以无亲缘关系的进程间。
3) 信号量 semophore: 锁机制，计数器，控制多个进程对共享内存访问。
4) 消息队列 message queue: 链表，从队列添加消息，读走消息。
5) 信号 signal: 通知进程某事件已经发生。
6) 套接字 socket: 不同机器上进程通信。
